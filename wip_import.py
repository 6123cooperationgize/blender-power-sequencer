import os
import bpy
from bpy.props import BoolProperty, IntProperty

from .functions.global_settings import ProjectSettings, Extensions
from .functions.file_management import *
from .functions.animation import add_transform_effect
from .functions.sequences import find_empty_channel


# TODO: Separate imports / img shouldn't be treated the same way as video, they deserve their own operator
# Then ImportLocFootage can call the import video, audio and img operators
# class ImportLocalImages(bpy.types.Operator):
#     bl_idname = 'gdquest_vse.import_images'
#     bl_label = 'Import local images'
#     bl_description = 'Import images found in the img folder \
#                       sitting next to the blend file.'
#     bl_options = {'REGISTER', 'UNDO'}

#     img_length = IntProperty(
#         name="Image strip length",
#         description="Controls the duration of the imported image strips length",
#         default=96,
#         min=1)
#     img_padding = IntProperty(
#         name="Image strip padding",
#         description="Padding added between imported image strips in frames",
#         default=24,
#         min=1)
#     # PSD related features
#     import_psd = BoolProperty(
#         name="Import PSD as image",
#         description="When True, psd files will be imported as individual image strips",
#         default=False)
#     ps_assets_as_img = BoolProperty(
#         name="Import PS assets as images",
#         description="Imports the content of folders generated by Photoshop's quick export \
#                     function as individual image strips",
#         default=True)

#     @classmethod
#     def poll(cls, context):
#         return True

#     def execute(self, context):


#         if created_img_strips:
#             add_transform_effect(created_img_strips)
#             for s in created_img_strips:
#                 s.select = True
#         return {'FINISHED'}




# TODO: Refactor, walk directories and collect filepaths, then send to function
#       to create strips
# TODO: By default, do not reimport existing strips, import only the new ones
# TODO: Use add-on preferences to change default image length
# TODO: add option to add fade in and/or out by default to pictures
# TODO: add option to add default animation (ease in/out on X axis) on
class ImportLocalFootage2(bpy.types.Operator):
    bl_idname = "gdquest_vse.import_local_footage_2"
    bl_label = "Import local footage 2"
    bl_description = "Import video and audio from the project folder to VSE strips"
    bl_options = {'REGISTER', 'UNDO'}

    always_import = BoolProperty(
        name="Always Reimport",
        description="If true, always import all local files to new strips. \
                    If False, only import new files (check if footage has \
                    already been imported to the VSE).",
        default=False)
    keep_audio = BoolProperty(
        name="Keep audio from video files",
        description="If False, the audio that comes with video files will not be imported",
        default=False)


    @classmethod
    def poll(cls, context):
        return True

    def execute(self, context):
        if not bpy.data.is_saved:
            self.report({"ERROR_INVALID_INPUT"}, "You need to save your project first. Import cancelled.")
            return {"CANCELLED"}

        sequencer = bpy.ops.sequencer
        context = bpy.context
        path = bpy.data.filepath

        bpy.ops.screen.animation_cancel(restore_frame=True)

        wm = bpy.context.window_manager
        SEQUENCER_AREA = {'region': wm.windows[0].screen.areas[2].regions[0],
                        'blend_data': bpy.context.blend_data,
                        'scene': bpy.context.scene,
                        'window': wm.windows[0],
                        'screen': bpy.data.screens['Video Editing'],
                        'area': bpy.data.screens['Video Editing'].areas[2]}

        # Empty channel
        channel_for_audio = 1 if self.keep_audio else 0
        empty_channel = find_empty_channel(mode='ABOVE')
        created_img_strips = []

        working_directory = get_working_directory(path)
        folders = {}

        folders_to_find = ProjectSettings.FOLDER_NAMES.AUDIO, ProjectSettings.FOLDER_NAMES.IMG, ProjectSettings.FOLDER_NAMES.VIDEO

        for folder in os.listdir(path=working_directory):
            if folder in folders_to_find:
                folders[folder] = working_directory + "\\" + folder

        img_folder = folders[ProjectSettings.FOLDER_NAMES.IMG]
        img_files = find_files(img_folder, Extensions.IMG, recursive=True)
        img_dict = files_to_dict(img_files, img_folder)
        print(img_files)
        for d in img_dict:
            print(d)
        # print(img_files)
        # To add files, need a list of dictionaries like
        # {'name': 'path'} where path is relative to filepath
        # audio_files = find_files(folders['audio'], Extensions.AUDIO)
        # video_files = find_files(folders['video'], Extensions.VIDEO, recursive=True)

        return {"FINISHED"}


def get_working_directory(path=None):
    if not path:
        return None

    project_name = bpy.path.basename(path)
    directory = path[:len(path) - (len(project_name) + 1)]
    return directory


# TODO: Ignore the blender proxy folders
def find_files(directory, file_extensions, recursive=False, ignore_folders=('_proxy')):
    """Walks through a folder and returns a list of filepaths that match the extensions."""
    if not directory and file_extensions:
        return None

    files = []

    from glob import glob
    from os.path import basename

    # TODO: Folder containing img files = img sequence
    for ext in file_extensions:
        source_pattern = directory + "\\"
        pattern = source_pattern + ext
        files.extend(glob(pattern))
        if not recursive:
            continue
        pattern = source_pattern + "**\\" + ext
        files.extend(glob(pattern))

    if basename(directory) == ProjectSettings.FOLDER_NAMES.IMG:
        psd_names = [f for f in glob(directory + "\\*.psd")]
        for i, name in enumerate(psd_names):
            psd_names[i] = name[len(directory):-4]

        psd_folders = (f for f in os.listdir(directory) if f in psd_names)
        for f in psd_folders:
            for ext in file_extensions:
                files.extend(glob(directory + "\\" + f + "\\" + ext))
    return files


# TODO: find correct filepaths
def files_to_dict(files, folder_path):
    """Converts a list of files to Blender's dictionary format for import
       Returns a list of dictionaries with the {'name': filename} format
       Args:
        - files: a list or a tuple of files
        - folder_path: a string of the path to the files' containing folder"""
    if not files and folder_path:
        return None

    dictionary = []
    for f in files:
        dict_form = {'name': f[len(folder_path)+1:]}
        dictionary.append(dict_form)
    return dictionary
