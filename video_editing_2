# TODO: Find efficient way to code the function
def find_strips_under_cursor(sequences):
    """Returns a list of sequences that the time cursor overlaps"""
    sequences_under_cursor = []
    if not sequences:
        sequences = bpy.context.sequences

    frame_current = bpy.context.scene.frame_current

    for s in sequences:
        if s.frame_final_start < frame_current < s.frame_final_end:
            sequences_under_cursor.append(s)

    return sequences_under_cursor

class TimeCursorCut(bpy.types.Operator):
    """Cuts the strips sitting under the time cursor"""
    bl_idname = "gdquest_vse.time_cursor_cut"
    bl_label = "Time Cursor Cut"
    bl_options = {'REGISTER', 'UNDO'}

    @classmethod
    def poll(cls, context):
        return context.scene is not None

    def execute(self, context):
        # Cuts a sound/video strip the time cursor overlaps, or linked, or everything under the cursor
        # v1: cuts everything under the time cursor
        sequencer = bpy.ops.sequencer
        scene = bpy.context.scene
        seq_ed = scene.sequence_editor
        current_frame = scene.frame_current

        strips = []

        # Search through all top level sequences
        # TEST IN META STRIP to see if it works
        for s in seq_ed.sequences:
            # if the time cursor is over the strip, add it to the list
            if s.frame_final_start < current_frame < s.frame_final_end:
                strips.append(s)
                pass
            pass

        if len(strips) > 0:
            sequencer.select_all(action='DESELECT')
            for s in strips:
                s.select = True
                pass
            sequencer.cut(frame=current_frame, type='SOFT', side='BOTH')
            sequencer.select_all(action='DESELECT')
            pass
        return {"FINISHED"}



class CutStrip(bpy.types.Operator):
    """Cuts like the normal cut tool, but selects both sides after the cut"""
    bl_idname = "gdquest_vse.cut_strip"
    bl_label = "Cut selected strips"
    bl_options = {'REGISTER', 'UNDO'}

    @classmethod
    def poll(cls, context):
        return context.scene is not None

    def execute(self, context):
        sequencer = bpy.ops.sequencer
        sequencer.cut(frame=bpy.context.scene.frame_current,
                      type='SOFT',
                      side='RIGHT')
        sequencer.select_more()
        return {"FINISHED"}
