# Keymap that changes operator property!

# assert not bpy.context.user_preferences.inputs.use_emulate_nu mpad
#
# mesh_sel_keymap = {
# 'ONE': "True, False, False",
# 'TWO': "False, True, False",
# 'THREE': "False, False, True"
# }
#
# uv_sel_keymap = {
# 'ONE': "VERTEX",
# 'TWO': "EDGE",
# 'THREE': "FACE",
# 'FOUR': "ISLAND"
# }
#
# wm = bpy.context.window_manager
# km = wm.keyconfigs.default.keymaps['Mesh']
#
# for k, v in mesh_sel_keymap.items():
#     kmi = km.keymap_items.new('wm.context_set_value', k, 'PRESS')
#     kmi.properties.data_path = 'tool_settings.mesh_select_mode'
#     kmi.properties.value = v
#
# kmi = km.keymap_items.new('wm.context_toggle', 'FOUR', 'PRESS')
# kmi.properties.data_path = 'space_data.use_occlude_
#
# km = wm.keyconfigs.default.keymaps['UV Editor']
#
# for k, v in uv_sel_keymap.items():
#     kmi = km.keymap_items.new('wm.context_set_enum', k, 'PRESS')
#     kmi.properties.data_path = 'tool_settings.uv_select_mode'
#     kmi.properties.value = v






# Invoke method: allows to get keyboard events on top of execute (i.e. do different things if user CTRL clicks on a button instead of simply clicking)

# class MyOperator(bpy.types.Operator):
#     bl_idname = "object.my_operator"
#     bl_label = "My Operator"
#
#     def invoke(self,context,event):
#         if event.ctrl:
#             do something
#         else:
#             do something else
#         return{"FINISHED"}

# Useful ops and paths
# bpy.ops.anim.change_frame(frame=266)
# bpy.app.debug_wm = True
