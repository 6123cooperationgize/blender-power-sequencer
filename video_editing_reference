def draw_callback_px(self, context):
    print("mouse points", len(self.mouse_path))

    region = context.region
    active = context.scene.sequence_editor.active_strip
    if active is None:
        return

    # Convert the active strip's (frame, channel) to (x, y) coordinates
    x = active.frame_final_start
    y = active.channel
    x, y = region.view2d.view_to_region(x, y)

    font_id = 0  # XXX, need to find out how best to get this.
    blf.position(font_id, x, y, 0)
    blf.size(font_id, 20, 72)
    # region_to_view gives the region coords.  x is frame, y is channel.
    x, y = region.view2d.region_to_view(*self.mouse_path[-1])
    blf.draw(font_id, "Hello Word %d %d" % (x, y))
    # move the frame to the mouse
    context.scene.frame_set(x)


class ModalDrawOperator(bpy.types.Operator):
    """Draw a line with the mouse"""
    bl_idname = "sequencer.modal_operator"
    bl_label = "Simple Modal Sequencer Operator"

    def modal(self, context, event):
        context.area.tag_redraw()
        region = context.region

        if event.type == 'MOUSEMOVE':
            self.mouse_path.append((event.mouse_region_x, event.mouse_region_y))

        elif event.type == 'LEFTMOUSE':
            bpy.types.SpaceSequenceEditor.draw_handler_remove(self._handle,
                                                              'WINDOW')
            return {"FINISHED"}

        elif event.type in {'RIGHTMOUSE', 'ESC'}:
            bpy.types.SpaceSequenceEditor.draw_handler_remove(self._handle,
                                                              'WINDOW')
            return {'CANCELLED'}

        return {'RUNNING_MODAL'}

    def invoke(self, context, event):
        if context.area.type == 'SEQUENCE_EDITOR':
            # the arguments we pass the the callback
            args = (self, context)
            # Add the region OpenGL drawing callback
            # draw in view space with 'POST_VIEW' and 'PRE_VIEW'
            self._handle = bpy.types.SpaceSequenceEditor.draw_handler_add(
                draw_callback_px, args, 'WINDOW', 'POST_PIXEL')

            self.mouse_path = []

            context.window_manager.modal_handler_add(self)
            return {'RUNNING_MODAL'}
        else:
            self.report({'WARNING'},
                        "You need to be in the Video Sequence Editor to use this tool. Operation cancelled.")
            return {'CANCELLED'}


class TimeCursorCut(bpy.types.Operator):
    """Cuts the strips sitting under the time cursor"""
    bl_idname = "gdquest_vse.time_cursor_cut"
    bl_label = "Time Cursor Cut"
    bl_options = {'REGISTER', 'UNDO'}

    @classmethod
    def poll(cls, context):
        return context.scene is not None

    def execute(self, context):
        # Cuts a sound/video strip the time cursor overlaps, or linked, or everything under the cursor
        # v1: cuts everything under the time cursor
        sequencer = bpy.ops.sequencer
        scene = bpy.context.scene
        seq_ed = scene.sequence_editor
        current_frame = scene.frame_current

        strips = []

        # Search through all top level sequences
        # TEST IN META STRIP to see if it works
        for s in seq_ed.sequences:
            # if the time cursor is over the strip, add it to the list
            if s.frame_final_start < current_frame < s.frame_final_end:
                strips.append(s)
                pass
            pass

        if len(strips) > 0:
            sequencer.select_all(action='DESELECT')
            for s in strips:
                s.select = True
                pass
            sequencer.cut(frame=current_frame, type='SOFT', side='BOTH')
            sequencer.select_all(action='DESELECT')
            pass
        return {"FINISHED"}



class CutStrip(bpy.types.Operator):
    """Cuts like the normal cut tool, but selects both sides after the cut"""
    bl_idname = "gdquest_vse.cut_strip"
    bl_label = "Cut selected strips"
    bl_options = {'REGISTER', 'UNDO'}

    @classmethod
    def poll(cls, context):
        return context.scene is not None

    def execute(self, context):
        sequencer = bpy.ops.sequencer
        sequencer.cut(frame=bpy.context.scene.frame_current,
                      type='SOFT',
                      side='RIGHT')
        sequencer.select_more()
        return {"FINISHED"}
